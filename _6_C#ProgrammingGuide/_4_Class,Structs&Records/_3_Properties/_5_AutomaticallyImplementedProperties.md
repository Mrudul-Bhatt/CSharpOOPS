### **Explanation: Automatically Implemented Properties in C#**

Automatically implemented properties (auto-properties) simplify property declarations in C# when no additional logic is required in the `get` or `set` accessors. These properties reduce boilerplate code by eliminating the need to explicitly define backing fields, making the code cleaner and more concise.

---

### **How Auto-Properties Work**

- When you declare an auto-property, the **C# compiler automatically creates a private, anonymous backing field** to store the propertyâ€™s value.
- This backing field is accessible only through the `get` and `set` accessors of the property.
  
#### **Example**:
```csharp
public class Customer
{
    public string Name { get; set; }
    public int CustomerId { get; set; }
}
```

The above code is equivalent to:
```csharp
public class Customer
{
    private string _name; // Compiler-generated backing field
    private int _customerId;

    public string Name
    {
        get { return _name; }
        set { _name = value; }
    }

    public int CustomerId
    {
        get { return _customerId; }
        set { _customerId = value; }
    }
}
```

---

### **Key Features of Auto-Properties**

1. **Simpler Declaration**:
   - Auto-properties allow you to define both `get` and `set` methods concisely:
     ```csharp
     public string Name { get; set; }
     ```

2. **Default Initialization**:
   - You can initialize auto-properties at the time of declaration, similar to fields:
     ```csharp
     public string FirstName { get; set; } = "Default Name";
     ```

3. **Immutable Properties**:
   Auto-properties can enforce immutability by restricting the setter:
   - **Get-Only Properties** (immutable except in the constructor):
     ```csharp
     public string Name { get; } = "Immutable Name";
     ```

   - **Init-Only Properties** (mutable during object construction):
     ```csharp
     public string Name { get; init; }
     ```

   Example usage:
   ```csharp
   var person = new Person { Name = "John" }; // Can only be set during initialization
   ```

   - **Private Setters** (modifiable only within the class):
     ```csharp
     public string Name { get; private set; }
     ```

---

### **Validation in Auto-Properties (C# 13 Preview)**

Starting with C# 13, the `field` keyword can be used to add validation logic to auto-properties without explicitly declaring a backing field.

#### **Example**:
```csharp
public string FirstName
{
    get;
    set
    {
        field = !string.IsNullOrWhiteSpace(value)
            ? value
            : throw new ArgumentException("First name cannot be null or empty.");
    }
} = "Jane";
```

- **How it works**:
  - `field` refers to the backing field automatically generated by the compiler.
  - Validation logic ensures that only valid data is assigned to the property.

---

### **Example: Auto-Properties in Action**

Here is an example of a class with auto-properties:

```csharp
public class Customer
{
    public double TotalPurchases { get; set; }
    public string Name { get; set; }
    public int CustomerId { get; set; }

    public Customer(double purchases, string name, int id)
    {
        TotalPurchases = purchases;
        Name = name;
        CustomerId = id;
    }
}

class Program
{
    static void Main()
    {
        // Create a new Customer object using auto-properties
        Customer cust1 = new Customer(5000.00, "John Doe", 12345);

        // Access and modify properties
        Console.WriteLine($"Customer: {cust1.Name}, Purchases: {cust1.TotalPurchases}");
        cust1.TotalPurchases += 250.00; // Modify TotalPurchases
        Console.WriteLine($"Updated Purchases: {cust1.TotalPurchases}");
    }
}
```

#### **Output**:
```
Customer: John Doe, Purchases: 5000
Updated Purchases: 5250
```

---

### **Auto-Properties in Interfaces**

Auto-properties **cannot** be declared in interfaces because:
1. Interfaces only define members without providing implementations.
2. Auto-properties inherently rely on a private backing field, which interfaces cannot have.

#### **Correct Interface Example**:
```csharp
public interface ICustomer
{
    string Name { get; set; } // No backing field, only accessor declarations
}
```

---

### **Making Classes Immutable with Auto-Properties**

1. **Get-Only Accessors**:
   - The property can only be assigned in the constructor:
     ```csharp
     public string Name { get; } = "Default";
     ```

2. **Init-Only Accessors**:
   - The property can only be assigned during object initialization:
     ```csharp
     public string Name { get; init; }
     ```

3. **Private Setters**:
   - The property can be modified only within the class:
     ```csharp
     public string Name { get; private set; }
     ```

#### **Example: Immutable Class**:
```csharp
public class Product
{
    public string Name { get; init; }
    public double Price { get; private set; }

    public Product(string name, double price)
    {
        Name = name;
        Price = price;
    }
}
```

---

### **Best Practices**

1. Use auto-properties when no extra logic is required in `get` or `set` methods.
2. Use `init` or `private set` to make properties immutable, ensuring better encapsulation.
3. For properties requiring validation, leverage the `field` keyword (C# 13) or manually implement the `get` and `set` methods.

---

### **Summary**

- Automatically implemented properties reduce boilerplate code by eliminating the need for explicit backing fields.
- They support default initialization and can enforce immutability with `init`, private setters, or get-only accessors.
- Starting with C# 13, the `field` keyword allows adding validation logic without explicit backing fields.