
### **Methods in C#**

In C#, a **method** is a reusable block of code that performs a specific task. Methods contain a series of statements that are executed when the method is called. They are fundamental to organizing and structuring your code for modularity, reusability, and readability.

---

### **Key Features of Methods**

1. **Method Declaration**:
   Methods are declared within a class, struct, or interface. A method's declaration includes:
   - Access modifier (`public`, `private`, etc.).
   - Optional modifiers (`abstract`, `virtual`, `sealed`, etc.).
   - Return type (data type or `void` if no value is returned).
   - Method name.
   - Parameters (if any), enclosed in parentheses.

   **Example**:
   ```csharp
   public int AddNumbers(int a, int b)
   {
       return a + b;
   }
   ```

---

2. **Method Signature**:
   The **signature** of a method consists of its name and the number, order, and types of its parameters. 
   - The **return type** is **not** part of the signature for method overloading but is for delegate compatibility.
   - The method name and parameter list must be unique within a class.

---

3. **The Main Method**:
   - Acts as the entry point of a C# application.
   - The Common Language Runtime (CLR) invokes the `Main` method when the program starts.
   - In top-level statement programs, the `Main` method is auto-generated by the compiler.

---

### **Method Example**

```csharp
abstract class Motorcycle
{
    public void StartEngine() { /* Starts the engine */ }
    protected void AddGas(int gallons) { /* Adds fuel */ }
    public virtual int Drive(int miles, int speed) { return miles * speed; }
    public abstract double GetTopSpeed(); // Must be implemented by derived classes.
}

class TestMotorcycle : Motorcycle
{
    public override double GetTopSpeed() => 120.5;

    static void Main()
    {
        TestMotorcycle moto = new TestMotorcycle();
        moto.StartEngine();
        moto.AddGas(10);
        int distance = moto.Drive(5, 40);
        Console.WriteLine($"Distance covered: {distance} miles.");
        Console.WriteLine($"Top speed: {moto.GetTopSpeed()} mph");
    }
}
```

---

### **Parameters vs. Arguments**

- **Parameters**:
  - Declared in the method signature.
  - Define what values the method requires.
  ```csharp
  int Square(int number) { return number * number; }
  ```

- **Arguments**:
  - Concrete values passed to the method when it's called.
  ```csharp
  int result = Square(5); // 5 is the argument.
  ```

---

### **Passing Parameters**

1. **Pass by Value**:
   - Default behavior for value types (e.g., `int`, `float`).
   - A copy of the value is passed, and changes inside the method do not affect the original variable.

   **Example**:
   ```csharp
   void ModifyValue(int value)
   {
       value += 10; // Changes only the copy.
   }

   static void Main()
   {
       int x = 5;
       ModifyValue(x);
       Console.WriteLine(x); // Outputs: 5
   }
   ```

2. **Pass by Reference**:
   - Use the `ref` or `out` keyword to pass a value-type by reference.
   - Allows changes inside the method to reflect outside.

   **Example with `ref`**:
   ```csharp
   void ModifyValue(ref int value)
   {
       value += 10;
   }

   static void Main()
   {
       int x = 5;
       ModifyValue(ref x);
       Console.WriteLine(x); // Outputs: 15
   }
   ```

---

### **Passing Reference Types**

- When you pass a reference type (e.g., a class object), the method receives a reference to the object, not a copy. Changes to the object are reflected outside the method.

**Example**:
```csharp
public class SampleRefType
{
    public int Value;
}

void ModifyObject(SampleRefType obj)
{
    obj.Value = 42; // Modifies the original object.
}

static void Main()
{
    SampleRefType refType = new SampleRefType { Value = 10 };
    ModifyObject(refType);
    Console.WriteLine(refType.Value); // Outputs: 42
}
```

---

### **Abstract, Virtual, and Override in Methods**

1. **Abstract Methods**:
   - Declared in abstract classes.
   - Must be implemented by derived classes.
   ```csharp
   public abstract class Vehicle
   {
       public abstract void Move();
   }

   public class Car : Vehicle
   {
       public override void Move() { Console.WriteLine("Car is moving."); }
   }
   ```

2. **Virtual Methods**:
   - Defined with a base implementation.
   - Can be overridden in derived classes.
   ```csharp
   public class Shape
   {
       public virtual void Draw() { Console.WriteLine("Drawing a shape."); }
   }

   public class Circle : Shape
   {
       public override void Draw() { Console.WriteLine("Drawing a circle."); }
   }
   ```

---

### **Method Overloading**

- Define multiple methods with the same name but different parameter lists.
- The compiler differentiates methods by their signatures.

**Example**:
```csharp
public class Calculator
{
    public int Add(int a, int b) => a + b;
    public double Add(double a, double b) => a + b;
}

static void Main()
{
    Calculator calc = new Calculator();
    Console.WriteLine(calc.Add(2, 3));        // Calls int version.
    Console.WriteLine(calc.Add(2.5, 3.5));    // Calls double version.
}
```

---

### **Key Points**
1. Methods are reusable code blocks that perform tasks.
2. Parameters define inputs, and arguments provide actual values.
3. Methods can be overloaded, overridden, or abstract.
4. Pass parameters by value (default) or by reference (`ref`, `out`).
5. Reference type objects passed to methods reflect changes outside the method.
6. Use `virtual` and `override` for polymorphism and extensibility.