### **Updating a Codebase with Nullable Reference Types**

Enabling nullable reference types in C# enhances code safety by detecting potential null reference issues at compile time. Transitioning a codebase to leverage this feature improves diagnostics, minimizes runtime errors, and ensures clarity on nullability expectations for variables. Here's a structured approach to perform this migration effectively:

* * * * *

### **1\. Plan Your Migration**

Before starting, consider the scope and activity level of your project. Choose a strategy that balances your team's workload and the state of the project:

### **Strategies:**

1.  **Nullable Enable as Default**
    -   Use when **actively developing** new features.
    -   New code benefits immediately from nullable annotations and static analysis.
    -   Requires adding `#nullable disable` to unprocessed files until warnings are addressed.
2.  **Nullable Disable as Default**
    -   Use for **mature and stable** projects focusing primarily on adding nullable annotations.
    -   Existing files are updated incrementally, with nullable enabled in individual files via `#nullable enable`.
3.  **Nullable Warnings as Default**
    -   Best for **two-phase migrations**:
        1.  First phase: Address nullable warnings while types remain "oblivious."
        2.  Second phase: Enable annotations to declare expected nullability explicitly.
4.  **Nullable Annotations as Default**
    -   Annotations are added before addressing warnings.
    -   Often results in a large number of immediate warnings, increasing upfront work.

* * * * *

### **2\. Enable Nullable Context**

Set the global nullable context in your project file by adding the `<Nullable>` tag in the `.csproj` file:

```
<PropertyGroup>
  <Nullable>enable</Nullable> <!-- Other options: disable, warnings, annotations -->
</PropertyGroup>

```

* * * * *

### **3\. Understand Nullable Contexts**

Nullable contexts determine how the compiler interprets reference types:

-   **Annotation Context:**

    Defines if reference types are considered nullable (`T?`) or non-nullable (`T`).

-   **Warning Context:**

    Controls whether the compiler generates warnings for potential nullability issues.

**Reference Type States:**

-   **Oblivious:** No nullability analysis is performed.
-   **Nonnullable:** Treated as non-nullable unless explicitly marked.
-   **Nullable:** Explicitly marked with `T?`, indicating potential null values.

**Default Null States:**

-   Nullable variables: `maybe-null`
-   Non-nullable variables: `not-null`
-   Oblivious variables: `not-null`

* * * * *

### **4\. Address Warnings**

Initially, warnings highlight potentially unsafe null operations. Address these to improve the safety of your codebase:

-   Use null-checking constructs (`if`, `??`, `?.`, etc.) to handle `null` values explicitly.
-   Refactor APIs to ensure clear nullability expectations.

Example:

```
public string? GetName(bool isValid)
{
    return isValid ? "ValidName" : null;
}

// Handle nullable return:
string? name = GetName(false);
if (name != null)
{
    Console.WriteLine(name.ToUpper());
}

```

* * * * *

### **5\. Enable Type Annotations**

After addressing warnings, enable annotations to declare nullability explicitly. This step changes reference types from "oblivious" to either:

-   **Nonnullable:** `string`
-   **Nullable:** `string?`

For example:

```
public string? GetNullableName();  // Nullable return value
public void PrintName(string name); // Non-nullable parameter

```

* * * * *

### **6\. Use Attributes for Complex APIs**

Some APIs have complex nullability rules that cannot be expressed with simple annotations. Use attributes to document these rules:

-   **`[MaybeNull]`**: A non-nullable type might return `null`.
-   **`[NotNull]`**: A nullable type will never return `null`.
-   **`[DisallowNull]`**: A nullable parameter cannot accept `null`.

Example:

```
public class Example
{
    [return: MaybeNull]
    public string GetValue(int id) => id > 0 ? "Valid" : null;
}

```

* * * * *

### **7\. Adjust for Generated Code**

Generated files are excluded from the global nullable context. These files often lack annotations and should be managed explicitly:

-   Add `#nullable` directives to control nullability in generated files if needed.
-   Generated files are recognized by:
    -   Comments (`<auto-generated>`)
    -   Specific filename patterns (e.g., `.generated.cs`, `.designer.cs`).

* * * * *

### **8\. Iterate and Refactor**

As you migrate, review and refactor code to align with nullable best practices:

-   Annotate APIs with expected nullability.
-   Avoid suppressing warnings unnecessarily (`!` operator) unless confident about the safety.
-   Remove any temporary `#nullable` directives once a file is fully processed.

* * * * *

### **9\. Finalize Migration**

After all warnings are addressed:

-   Set the nullable context globally to `enable` in the project file.
-   Remove unnecessary pragmas and preprocessor directives.
-   Monitor new warnings as dependencies update or new code is added.

* * * * *

### **Key Benefits of Migration**

-   Enhanced **static analysis** to prevent runtime null reference errors.
-   Clear documentation of nullability expectations in APIs.
-   Safer and more maintainable codebase over time.

By adopting nullable reference types thoughtfully, you build resilience against one of the most common causes of runtime exceptions in .NET applications.