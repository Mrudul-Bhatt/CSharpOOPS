### **Source Generators in Native AOT**

In **Native AOT** (Ahead-of-Time) compilation, unused code is **trimmed** during publishing to reduce the application's size and improve performance. However, **reflection**—a powerful feature in C#—is often used in .NET applications to dynamically inspect or discover types at runtime, which is incompatible with Native AOT because the trimmed code may result in missing types at runtime.

To address this, **Source Generators** are used to **generate code at compile-time** that avoids the need for reflection. These generated codes are specifically designed to be **compatible with Native AOT**, ensuring that the app can function without the overhead or limitations of reflection.

---

### **Viewing Generated Code**

If you want to inspect the source code generated by the source generators, you can enable the `EmitCompilerGeneratedFiles` property in the `.csproj` file of your application:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <!-- Other properties omitted for brevity -->
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
  </PropertyGroup>
</Project>
```

After this change, run the `dotnet build` command. The generated code will be saved in a `generated/` directory under `obj/Debug/net8.0/`. You can explore this folder to see the files that were created during the build process.

Additionally, when using `dotnet publish`, the source files are compiled, and the generated code is passed to a **native IL compiler** (Intermediate Language compiler), which produces a native executable containing machine code.

---

### **Libraries and Native AOT**

Many libraries in the .NET ecosystem are not immediately compatible with Native AOT because they may rely on dynamic features like:

- **Reflection** to inspect types.
- **Dynamically loading libraries** at runtime.
- **Generating code on the fly** for certain functionalities.

These libraries will need to be **updated** to work seamlessly with Native AOT, possibly with the use of **Roslyn source generators**—a tool for generating source code at compile-time.

To make a library compatible with Native AOT, authors are encouraged to:

1. Read about **Native AOT compatibility requirements**.
2. Prepare their libraries for **trimming**, which is essential for minimizing the size of the application in Native AOT.

---

### **Minimal APIs and JSON Payloads**

In Native AOT, the **Minimal API** framework is designed to efficiently handle **JSON payloads**. The framework utilizes **System.Text.Json** for serialization and deserialization, and when used with Native AOT, it imposes additional compatibility requirements:

- All types that are sent as part of the HTTP body or returned from **request delegates** must be configured on a **`JsonSerializerContext`** registered in the **dependency injection (DI) container**.

To work with Native AOT, **source generators** are used to generate serialization code for JSON, which replaces reflection-based serialization. This ensures that the app remains compatible with the trimming and AOT compilation model.

---

### **Code Example: Using JSON Source Generators with Minimal APIs**

Here’s an example of how to implement the **JSON source generators** for a **Minimal API** app that uses Native AOT:

```csharp
using System.Text.Json.Serialization;
using MyFirstAotWebApi;

var builder = WebApplication.CreateSlimBuilder(args);
builder.Logging.AddConsole();

builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
});

var app = builder.Build();

var sampleTodos = TodoGenerator.GenerateTodos().ToArray();

var todosApi = app.MapGroup("/todos");
todosApi.MapGet("/", () => sampleTodos);
todosApi.MapGet("/{id}", (int id) =>
    sampleTodos.FirstOrDefault(a => a.Id == id) is { } todo
        ? Results.Ok(todo)
        : Results.NotFound());

app.Run();

// JSON Serializer Context for the ToDo array
[JsonSerializable(typeof(Todo[]))]
internal partial class AppJsonSerializerContext : JsonSerializerContext
{
}
```

#### Key Points in the Code:

1. **`JsonSerializerContext` Registration**: The `AppJsonSerializerContext` is registered with **dependency injection**. This context is responsible for generating the serialization code needed for Native AOT.
   
2. **`[JsonSerializable]` Attribute**: The `Todo[]` type is annotated with the `[JsonSerializable]` attribute. This tells the **source generator** to generate the necessary serialization logic for the `Todo[]` array at compile time.
   
3. **Mapping Endpoints**: The **Minimal API** is configured with a `/todos` route, which handles requests and uses the generated serialization code to send and receive data in JSON format.

---

### **Handling Non-Serializable Parameters**

Sometimes, you may have parameters in your API routes that are not directly involved in JSON serialization, like query string parameters. In these cases, these parameters don’t need to be serializable.

For example:

```csharp
public class Todo
{
    public int Id { get; set; }
    public string? Title { get; set; }
    public DateOnly? DueBy { get; set; }
    public bool IsComplete { get; set; }
}
```

In this example, the `Todo` class is used to represent the data returned from an API endpoint, and it's serializable. But if there were query string parameters in the API (e.g., filtering or sorting), they wouldn’t need serialization if they are **rich object types** and implement interfaces like `IParsable<T>`.

---

### **Conclusion**

Source generators play a crucial role in enabling **Native AOT** support in ASP.NET Core applications by replacing reflection-based code with statically generated code. This ensures that apps remain efficient and compatible with the **trimming process**. For **Minimal APIs**, it is essential to use **`JsonSerializerContext`** and source generators to handle JSON serialization at compile-time, as this eliminates the need for reflection, which is unsupported in Native AOT. Library authors and developers must also prepare their code for trimming and be aware of any compatibility issues when working with Native AOT.