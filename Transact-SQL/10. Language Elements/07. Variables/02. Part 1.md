Great! Let‚Äôs go over the **three key parts** of the Microsoft Docs article on Transact-SQL variables:

> **SET @local\_variable**
> **SELECT @local\_variable**
> **DECLARE @local\_variable**

These are core components of **using variables in SQL Server**. I‚Äôll explain each in detail with syntax, use cases, and examples.

---

## üîπ 1. `DECLARE @local_variable`

### ‚û§ Purpose:

Used to **declare** a local variable in T-SQL.

### ‚û§ Syntax:

```sql
DECLARE @variable_name data_type [ = initial_value ];
```

* `@variable_name` ‚Äî must begin with `@`.
* `data_type` ‚Äî any valid SQL Server data type (e.g., `INT`, `VARCHAR(50)`, `DATE`).
* You can **optionally initialize** it with a value.

### ‚û§ Example:

```sql
DECLARE @StudentId INT;
DECLARE @Name NVARCHAR(100) = 'John';
```

You can also declare multiple variables in one statement:

```sql
DECLARE @Id INT, @Name NVARCHAR(50), @DOB DATE;
```

---

## üîπ 2. `SET @local_variable`

### ‚û§ Purpose:

Used to **assign a value** to a previously declared variable.

### ‚û§ Syntax:

```sql
SET @variable_name = expression;
```

* Assigns **one variable at a time**.
* Often used for simple values or scalar results from a query.

### ‚û§ Example:

```sql
DECLARE @Count INT;
SET @Count = 10;
```

#### üî∏ From a Query:

```sql
DECLARE @StudentName NVARCHAR(50);
SET @StudentName = (SELECT Name FROM Students WHERE StudentID = 1001);
```

> ‚ö†Ô∏è If the subquery returns **more than one row**, it raises an error:

```
Msg 512, Level 16, Subquery returned more than 1 value.
```

---

## üîπ 3. `SELECT @local_variable`

### ‚û§ Purpose:

Also used to **assign values** to one or more variables, often from a result set.

### ‚û§ Syntax:

```sql
SELECT @var1 = expression1, @var2 = expression2, ...
[ FROM table WHERE condition ];
```

* Can **assign multiple variables** in a single statement.
* Allows assignment directly from a **row in a table**.

### ‚û§ Example:

```sql
DECLARE @Name NVARCHAR(50), @Age INT;

SELECT @Name = Name, @Age = Age
FROM Students
WHERE StudentID = 1001;
```

> ‚ö†Ô∏è If the query returns **multiple rows**, `SELECT` does **not raise an error** ‚Äî it just assigns values from the **last row returned**.

---

## üîÑ Comparison: `SET` vs. `SELECT`

| Feature                     | `SET`   | `SELECT`                     |
| --------------------------- | ------- | ---------------------------- |
| Assign multiple variables   | ‚ùå No    | ‚úÖ Yes                        |
| Assign from query (1 row)   | ‚úÖ Yes   | ‚úÖ Yes                        |
| Multiple rows returned      | ‚ùå Error | ‚úÖ No error, assigns last row |
| Better for debugging/safety | ‚úÖ Yes   | ‚ö†Ô∏è Less predictable          |

---

## ‚úÖ Full Example Using All Three

```sql
-- Declare variables
DECLARE @StudentId INT, @Name NVARCHAR(50), @Age INT;

-- Assign using SET
SET @StudentId = 1001;

-- Assign using SELECT from table
SELECT @Name = Name, @Age = Age
FROM Students
WHERE StudentID = @StudentId;

-- Use the variables
PRINT 'Student: ' + @Name + ', Age: ' + CAST(@Age AS NVARCHAR);
```

---

## Summary

| Statement | Purpose                             |
| --------- | ----------------------------------- |
| `DECLARE` | Declares a new variable             |
| `SET`     | Assigns a value (one variable only) |
| `SELECT`  | Assigns one or multiple variables   |

Each has a role depending on whether you're declaring, assigning static values, or pulling from a result set.

Let me know if you want an example inside a stored procedure or function!
